---
title: 常见查找算法
tags:
  - 笔记
  - 算法
categories:
  - 笔记
  - 算法
mathjax: true
date: 2018-07-14 08:25:56
---

# 简介

查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算。这里介绍常见的几种查找算法。

查找定义：根据给定的某个值，在查找变中确定一个其关键字等于给定值的数据元素

查找算法分类：

（1）静态查找和动态查找:
静态或则动态都是针对查找表而言的，静态表指的是只作查找的表，动态表指查找表中有删除和插入操作的表  

静态表查找方法：顺序表查找、有序表查找、线性索引查找
动态表查找方法：二叉排序树、平衡二叉树（AVL树）、多路查找树（B树）

（2）无序查找和有序查找；无序查找：被查找的数列有序无序均可。有序查找：被查找的数列必须为有序数列

平均查找长度（Average Search Length, ASL）：需和制定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度

对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。
Pi：查找表中第i个数据元素的概率。
Ci：找到第i个数据元素时已经比较过的次数。

# 顺序查找

**说明：顺序查找适合于存储结构为顺序或者链接存储的线性表**

基本思想：顺序查找也称为线性查找，是在一个已知无(或有序）序队列中找出与给定关键字相同的数的具体位置。原理是让关键字与队列中的数从第一个开始逐个比较，直到找出与给定关键字相同的数为止，它的缺点是效率低下。

复杂度： O(N)

``` java
public static int sequenceSearch(int[] array, int des) {
    for (int i = 0, len = array.length; i < len; i++) {
        if (array[i] == des) {
            return i;
        }
    }
    return -1;
}
```

# 二分查找

**说明：二分查找为有序查找，数列必须有序，否则需要先进性排序操作**

基本思想：也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。

复杂度：最坏为 $$\log_2 (n+1)$$,期望时间复杂度为$$O(\log_2 n))$$

``` java
  /**
   * 二分查找
   * @param arr 目标数组
   * @param key 关键字
   * @return 目标数组的索引
   */
  public static int binarySearch(int[] arr, int key) {
    return binarySearch(arr, key, 0, arr.length - 1);
  }

  private static int binarySearch(int[] arr, int key, int low, int hight) {
    int mid = (low + hight) / 2;
    if (arr[mid] == key) {
      return mid;
    } else if (arr[mid] < key) {
      low = mid + 1;
      return binarySearch(arr, key, low, hight);
    } else {
      hight = mid - 1;
      return binarySearch(arr, key, low, hight);
    }
  }
```

# 插值查找

基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率，当然插值查找也属于有序查找。

对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。

复杂度分析：查找成功或者失败的时间复杂度均为$$O(\log_2 (\log_2 n))$$

``` java
/**
   * 插入查找
   *
   * @param arr 目标数组
   * @param key 关键字
   * @return 目标数组的索引
   */
  public static int insertSearch(int[] arr, int key) {
    return insertSearch(arr, key, 0, arr.length - 1);
  }

  private static int insertSearch(int[] arr, int key, int low, int high) {
    // 把二分查找的比例参数改为自适应的，让mid值的变化更加靠近关键字key，间接减少比较次数
    int mid = low + (key - arr[low]) / (arr[high] - arr[low]) * (high - low);
    if (arr[mid] == key) {
      return mid;
    } else if (arr[mid] < key) {
      low = mid + 1;
      return insertSearch(arr, key, low, high);
    } else {
      high = mid - 1;
      return insertSearch(arr, key, low, high);
    }
  }
```

# 斐波那契查找

黄金分割：是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。

大家记不记得斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（从第三个数开始，后边每一个数都是前两个数的和）。然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。

基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。

相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：
　　1）相等，mid位置的元素即为所求

　　2）>，low=mid+1;

     3）<，high=mid-1。

　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;

 开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种

　　1）相等，mid位置的元素即为所求

　　2）>，low=mid+1,k-=2;

　　说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。

　　3）<，high=mid-1,k-=1。

　　说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。

复杂度分析：最坏情况下，时间复杂度为$$O(\log_2 n)$$，且其期望复杂度也为$$O(\log_2 n)$$。

``` c++
// 斐波那契查找.cpp 

#include "stdafx.h"
#include <memory>
#include  <iostream>
using namespace std;

const int max_size=20;//斐波那契数组的长度

/*构造一个斐波那契数组*/ 
void Fibonacci(int * F)
{
    F[0]=0;
    F[1]=1;
    for(int i=2;i<max_size;++i)
        F[i]=F[i-1]+F[i-2];
}

/*定义斐波那契查找法*/  
int FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字
{
  int low=0;
  int high=n-1;
  
  int F[max_size];
  Fibonacci(F);//构造一个斐波那契数组F 

  int k=0;
  while(n>F[k]-1)//计算n位于斐波那契数列的位置
      ++k;

  int  * temp;//将数组a扩展到F[k]-1的长度
  temp=new int [F[k]-1];
  memcpy(temp,a,n*sizeof(int));

  for(int i=n;i<F[k]-1;++i)
     temp[i]=a[n-1];
  
  while(low<=high)
  {
    int mid=low+F[k-1]-1;
    if(key<temp[mid])
    {
      high=mid-1;
      k-=1;
    }
    else if(key>temp[mid])
    {
     low=mid+1;
     k-=2;
    }
    else
    {
       if(mid<n)
           return mid; //若相等则说明mid即为查找到的位置
       else
           return n-1; //若mid>=n则说明是扩展的数值,返回n-1
    }
  }  
  delete [] temp;
  return -1;
}

int main()
{
    int a[] = {0,16,24,35,47,59,62,73,88,99};
    int key=100;
    int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);
    cout<<key<<" is located at:"<<index;
    return 0;
}
```

# 树表查找

## 1. 最简单的鼠标查找--二叉树查找算法

基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 

`二叉查找树`（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：

　　1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

　　2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

　　3）任意节点的左、右子树也分别为二叉查找树。

**二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。**

![二叉查找树](/images/1333691114_6839.jpg)

复杂度分析：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

基于对二叉查找树进行优化，进而可以得到其他树表查找算法，如`平衡树`，`红黑树`等高效算法

## 2. 平衡查找树--2-3查找树（2-3 Tree)

为了保证在最差的情况下也能达到logN的效率，引入了平衡查找树。因此需要保证树在插入之后始终保持平衡状态，这就是**平衡查找树**。

2-3查找树：和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下：

（1）要么为空，要么：
（2）对于2节点，该节点保存一个key及其对应的value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。
（3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。

**2-3查找树的性质：**

1）如果中序遍历2-3查找树，就可以得到排好序的序列；

2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）

复杂度分析：

2-3树的查找效率与树的高度是息息相关的。

- 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN
- 在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN

## 3. 平衡查找树--红黑树（Red-Black Tree)

2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。

基本思想：红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。

![](/images/270024368439888.png)

**红黑树定义：**  
红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：

- 红色节点向左倾斜
- 一个节点不可能有两个红色链接
- 整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。

还有一种定义：

红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或者黑色，除了二叉查找树的要求外，还满足如下要求：

（1）节点是红色或者黑色
（2）根节点是黑色
（3）每个叶节点（NIL节点，空节点）是黑色的
（4）每个红色节点的两个子节点都是黑色（从每个叶子到根节点的所有路径上不能有两个连续的红色节点）
（5）从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

![](/images/270024403113529.png)

红黑树的性质：整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。

复杂度分析：最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。

![](/images/270027368747653.png)

红黑树的平均高度大约为logn。

## 4. B树和B+树（B Tree/B+ Tree）

平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。

维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。

B树定义：

　　B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。

根节点至少有两个子节点

每个节点有M-1个key，并且以升序排列

位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间

其它节点至少有M/2个子节点

　　下图是一个M=4 阶的B树:

![](/images/290047034539184.png)

　可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入  
6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4
的演示动画：

![](/images/btreebuild.gif)

B+树定义：

　　B+树是对B树的一种变形树，它与B树的差异在于：

有k个子结点的结点必然有k个关键码；
非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。
　　如下图，是一个B+树:
![](/images/290050048129679.png)

下图是B+树的插入动画：

![](/images/Bplustreebuild.gif)

**B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。**

B+ 树的优点在于：

- 由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。

- B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。

**但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。**

　B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中，如：

Windows：HPFS文件系统；
Mac：HFS，HFS+文件系统；
Linux：ResiserFS，XFS，Ext3FS，JFS文件系统；
数据库：ORACLE，MYSQL，SQLSERVER等中。
　　有关B/B+树在数据库索引中的应用，请看张洋的[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。

参考文档：
- [B树和B+树的插入、删除图文详解](https://www.cnblogs.com/nullzx/p/8729425.html)
- [【经典数据结构】B树与B+树](https://www.cnblogs.com/vincently/p/4526560.html)
- [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

树表查找总结：

　　二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。

　　除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。

![查找](/images/270027378905711.png)

# 分块查找

分块查找又称索引顺序查找，它是顺序查找的一种改进方法。
　　算法思想：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……
　　算法流程：
　　step1 先选取各块中的最大关键字构成一个索引表；
　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。

# 哈希查找

## 什么是哈希表（Hash）？

哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素"分类"，然后将这个元素存储在相应"类"所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了"冲突"，换句话说，就是把不同的元素分在了相同的"类"之中。后面我们将看到一种解决"冲突"的简便做法。

**总的来说，"直接定址"与"解决冲突"是哈希表的两大特点。**

只接定址可以提高查找速度，但是需要大量存储空间，通常查找的时间复杂度越低，空间复杂度越高

数组的特点是：寻址容易，插入和删除困难；

而链表的特点是：寻址困难，插入和删除容易。

那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。

## 什么是哈希函数？

　　哈希函数的规则是：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。

算法思想：哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。

### 算法流程：

　　1）用给定的哈希函数构造哈希表；
　　2）根据选择的冲突处理方法解决地址冲突；
　　　　常见的解决冲突的方法：拉链法和线性探测法。
　　3）在哈希表的基础上执行哈希查找。

哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。

### 复杂度分析：

　　单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。

### 哈希函数的构造：

采用哈希函数的关键作用是减少需要被处理的数组大小。在构造散列函数时有几点需要加以注意：

- 其一、散列函数的定义域必须包括需要存储的全部数据元素的关键字，而如果散列表允许有m个地址时，其值域必须在0到m-1之间；
- 其二、散列函数计算出来的地址应能均匀分布在整个地址空间中，若key是从关键字集合中随机抽取的一个关键字，散列函数应能以同等概率取0到m-1中的每一个值；
- 其三、散列函数应是简单的，能在较短的时间内计算出结果。下面我们介绍几个散列函数。

#### 1. 直接地址法

此类函数取关键字的某个线性函数值作为散列地址：Hash（key）=a*key+c （其中a、c是整常数）

这类散列函数是一对一的映射，一般不会产生冲突，但是，它要求散列地址空间的大小与关键字集合的大小相同，这种要求是很苛刻的。特别是当关键字集合很大而且又不连续时，这种方法就不太适宜。

#### 2. 数字分析法

设数据表的长度为n，数据元素的关键字是一个d位数，关键字上每一位可能有r种不同的符号。这r种不同的符号在各位上出现的概率不一定相同，可能在某些位上分布均匀，出现的机会均等；在某些位上分布不均匀，只有某几种符号经常出现。数字分析法就是根据散列表的大小，在关键字中选取某些分布均匀的若干位作为散列地址。

#### 3. 除留余数法

设散列表地址空间大小为m，取一个不大于m，但最接近于或等于m的质数p，或者选取一个不含有小于20的质因数的合数作为除数，除留余数法的散列函数为：

Hash（key）=key % p （p≤m, p 避免去2的幂）

#### 4. 乘余取整法（乘法散列法）

使用此方法时，先让关键字key乘上一个常数a(0＜a＜1)，提取乘积的小数部分，然后再用整数n乘以这个值，对结果向下取整，把它作为散列地址

$$ h(k)=n*(kA - \left \lfloor kA \right \rfloor)$$
$$ h(k)=\left \lfloor n(kA mod 1) \right \rfloor$$

## 如何解决Hash冲突

### 1. 链地址法

数组 + 链表，把哈希到同一位置的所有元素都放到一个链表中，桶结构

创建一个存放单词链表的数组，数组内不直接存放单词，这样，当冲突发生时，新的数据项直接接到数组下标所指的链表中，这种方法叫做链地址法。

![](/images/20160603152626346.png)

### 2. 开放地址法或者叫再散列法

基本思想是，当产生哈希冲突时，即关键字key的地址p=hash(key)上已经有值了，那么这次以p为基础，产生另外一个哈希地址p1,如果p1不冲突了，那么就将元素key存在位置p1,如果p1也冲突，就计算hash(p1)=p2，不冲突就存在p2,冲突继续计算；

再散列有几种方式：

1>线性探测再散列：冲突发生时，查看下个位置是否空，然后遍历下去找到个空的地方存放；

2>二次探测再散列：冲突发生时，在表的左右进行跳跃探测，di=12 -12 22 -22....k2 -k2;

3>伪随机探测再散列：di=伪随机序列；

公式如下：

$$ Hi = (H(key) + d_i) MOD m ,  i = 1, 2, ...., s$$

例子：hash表长度11，哈希函数是：

h(key) = key%11;那么h(47)=3,h(26)=4,h(60)=5;下一个关键字69，h(69)=3,与47冲突了

1>线性探测的解决方法：往后遍历找到个空的位置

            0 1 2     3     4    5    6     7     8     9     10

                     47     26   60   69 

2>二次探测再散列：下个哈希地址是h1 = (3+12)%11 = 4,冲突，再找下一个哈希地址，(3-12)%11 = 2，就放在第二个位置

3>再看看伪随机数的处理办法，假设随机数是：2 5 9 ，下一个哈希地址（3+2）%11 = 5，冲突，再找下一个，（3+5）%11 = 8，就放在8的位置了。

### 3. 在哈希法

这种方法是同时构造多个不同的哈希函数：hi = rhi(key) i=1,2...k

当哈希地址rh1(key)冲突时，再计算hi = rh2(key)....直到不再冲突

### 4. 建立一个公共溢出区间

这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。
